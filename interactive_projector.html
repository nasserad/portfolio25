<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portfolio</title>
    <!-- <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script> -->
    <script type="module">
        import { animate } from "https://cdn.jsdelivr.net/npm/motion@10.16.3/+esm";
        import { interpolate } from "https://cdn.jsdelivr.net/npm/flubber@0.4.2/+esm";

        window.animate = animate;
        window.interpolate = interpolate;
    </script>
</head>

<body>
    <script>

        //[*] stuff left to work on:
        // DONE: creation of the actual design assets. 
        // DONE: adding the creation of (the picture/slideshow/video assets to show/hide when design asset activated) to be included within the code.
        // 3. adding the tweaks. refactoring the code (if needed). need an overloaded hide/show function version for the tweaks array (maybe embed a sequential animation within it).

        //{*} extra stuff:
        // -  way too many calls happening (either proof with w/ a callonce flag check function (cheap soln i feel) or optimize listeners to be smarter.)
        // -  optimizing listeners.
        // -  rethink factory + singleton pattern for mediatypes. overkill or keep it?

        rmWidgetsClassNames = {
            default: "rmwidget",
            textV3: "widget-text-v3",
            shape: "widget-shape",
            button: "widget-button"
        }

        function isOverlapping(elementOrRect1, elementOrRect2) {
            const rect1 = elementOrRect1 instanceof Element
                ? elementOrRect1.getBoundingClientRect()
                : elementOrRect1;
            const rect2 = elementOrRect2 instanceof Element
                ? elementOrRect2.getBoundingClientRect()
                : elementOrRect2;

            return !(
                rect1.right < rect2.left ||    //rectONE is completely to the left of rectTWO
                rect1.left > rect2.right ||    //rectONE is completely to the right of rectTWO
                rect1.bottom < rect2.top ||    //rectONE is completely above rectTWO
                rect1.top > rect2.bottom       //rectONE is completely below rectTWO
            );
        }

        let wasOverlapping = false;
        let interactionCooldown = false;

        function callOnce() {
            if (interactionCooldown) return;

            const projector = new Projector();
            const el = projector.elements;

            const manager = new DesignAssetManager();
            const activeAsset = manager.getCurrentTarget();

            const isCurrentlyOverlapping = activeAsset && isOverlapping(activeAsset.assetEl, el.foreground);

            if (isCurrentlyOverlapping !== wasOverlapping) {
                interactionCooldown = true; // prevent overlap checking

                if (isCurrentlyOverlapping) {
                    activeAsset.activate();
                } else if (activeAsset) {
                    activeAsset.deactivate();
                }

                wasOverlapping = isCurrentlyOverlapping;

                //reset cooldown
                setTimeout(() => {
                    interactionCooldown = false;
                }, 300);
            }
        }

        //util functions
        function throttle(func, delay) {
            let lastCall = 0;
            return (...args) => {
                const now = Date.now();
                if (now - lastCall >= delay) {
                    lastCall = now;
                    func(...args);
                }
            };
        }

        function hideElement(el, status) {
            if (!el) return;
            el.style.transition = "transform 1.0s ease";
            el.style.display = status ? "none" : "block";
        }

        function applyTransition(el, propertiesList, duration = "0.6s", easing = "ease") {
            if (!el) return;

            const bananaList = Array.isArray(propertiesList) ? propertiesList : [propertiesList];
            const transitionString = bananaList.map(banana => `${banana} ${duration} ${easing}`).join(", ");

            el.style.transition = transitionString;
        }

        _interpolatorCache = new Map();
        function getInterpolator(oldD, newD, maxSegmentLength) {
            const key = oldD + ' ' + newD + ' ' + maxSegmentLength;
            if (!_interpolatorCache.has(key)) {
                _interpolatorCache.set(
                    key,
                    window.interpolate(oldD, newD, { maxSegmentLength })
                );
            }
            return _interpolatorCache.get(key);
        }

        /**
         * Batch‑morph a set of <path> elements from their current `d`→ newD.
         * Extensive debug logging to pinpoint failures.
         */
        function morphAll(paths, newD, { duration = 0.6, easing = 'ease-in-out', maxSegmentLength = 2 } = {}) {
            console.log('   7. Enter morphAll() {totalPaths:', paths.length, 'newD:', newD, '}');

            const items = paths
                .map(el => {
                    const oldD = el.getAttribute('d');
                    if (!oldD || oldD === newD) {
                        console.log('       skip path (no oldD or already new)');
                        return null;
                    }
                    try {
                        const interp = getInterpolator(oldD, newD, maxSegmentLength);
                        console.log('       ✓ interp created for element:', el);
                        return { el, interp };
                    } catch (err) {
                        console.warn('       flubber failed, fallback to instant', err);
                        el.setAttribute('d', newD);
                        return null;
                    }
                })
                .filter(Boolean);

            console.log('   8. items to animate:', items.length, items);

            if (items.length === 0) {
                console.log('   9. No paths to animate');
                return;
            }

            // proxy object for the tween
            const proxy = { t: 0 };
            console.log('  10. starting Motion animate on proxy');

            // animate proxy.t from 0 → 1
            animate(proxy, { t: 1 }, {
                duration,
                easing,
                onUpdate: ({ t }) => {
                    for (const { el, interp } of items) {
                        el.setAttribute('d', interp(t));
                    }
                },
                onComplete: () => console.log('   11. morphAll() complete')
            });
        }

        class Projector {
            constructor() {
                if (Projector.instance) return Projector.instance;

                this.rmWidgetsClassNames = rmWidgetsClassNames;

                //constants: widget IDs
                this.ids = {
                    title: "67dd66c63a64f2281b928afb",
                    text: "67d47a32802660506c48d088",
                    projectorBackground: "67e9f5d805137a26916fce6f",
                    projectorForeground: "67e9f5d862ecc0be7cff9d44",
                    hintText: "67e9f5d96855af5ad56d85e4",
                    userImg: "67e9f5d9c5a5ce602fac3f88",
                    userName: "67e9f5d928c042804157b29a",
                    closeBtn: "67eacf150c89adeaeb487c02",
                    actionBtn: "67eacf1511d353e4afae09d2"
                };

                // DOM references
                this.elements = {
                    title: this._queryText(this.ids.title),
                    text: this._queryText(this.ids.text),
                    hintText: this._queryText(this.ids.hintText),
                    userName: this._queryText(this.ids.userName),

                    background: this._queryShape(this.ids.projectorBackground),
                    backgroundFill: this._queryShape(this.ids.projectorBackground, 'path[mask]'),
                    backgroundOutline: this._queryShape(this.ids.projectorBackground, 'path[clip-path]'),

                    foreground: this._queryShape(this.ids.projectorForeground),
                    foregroundFill: this._queryShape(this.ids.projectorForeground, 'path[mask]'),
                    foregroundOutline: this._queryShape(this.ids.projectorForeground, 'path[clip-path]'),

                    userImg: this._queryShape(this.ids.userImg, 'ellipse[mask]'),

                    closeBtn: this._queryButton(this.ids.closeBtn),
                    actionBtn: this._queryButton(this.ids.actionBtn)
                };

                const bgSvg = this.elements.background.querySelector('svg');
                const fgSvg = this.elements.foreground.querySelector('svg');

                // cache background-only paths
                this._bgMorphPaths = Array.from(
                    bgSvg.querySelectorAll(
                        'defs mask path, defs clipPath path, path[mask], path[clip-path]'
                    )
                );

                // cache foreground-only paths
                this._fgMorphPaths = Array.from(
                    fgSvg.querySelectorAll(
                        'defs mask path, defs clipPath path, path[mask], path[clip-path]'
                    )
                );

                this.originX = 0;
                this.originY = 0;
                Projector.instance = this;
            }

            //helpers
            _queryText(id) {
                return document.querySelector(`div.${this.rmWidgetsClassNames.default}.${this.rmWidgetsClassNames.textV3}[data-id="${id}"]`);
            }

            _queryShape(id, child = "") {
                return document.querySelector(`div.${this.rmWidgetsClassNames.default}.${this.rmWidgetsClassNames.shape}[data-id="${id}"] ${child}`);
            }

            _queryButton(id) {
                return document.querySelector(`div.${this.rmWidgetsClassNames.default}.${this.rmWidgetsClassNames.button}[data-id="${id}"]`);
            }

            _generateNewD(width, height, radius) {
                const r = radius;
                const w = width;
                const h = height;

                return `
                M${r} 0
                A${r} ${r} 0 0 0 0 ${r}
                L0 ${h - r}
                A${r} ${r} 0 0 0 ${r} ${h}
                L${w - r} ${h}
                A${r} ${r} 0 0 0 ${w} ${h - r}
                L${w} ${r}
                A${r} ${r} 0 0 0 ${w - r} 0
                Z
            `.replace(/\s+/g, ' ').trim();
            }

            //methods
            setOrigin(x, y) {
                this.originX = x;
                this.originY = y;
            }

            applyTransform(el, offsetX = 0, offsetY = 0) {
                if (!el) return;
                const x = this.originX + offsetX;
                const y = this.originY + offsetY;
                el.style.transform = `translate(${x}px, ${y}px)`;
                applyTransition(el, "transform");
            }

            _setSvgDimensions(containerEl, svg, width, height) {
                const viewBox = `0 0 ${width} ${height}`;
                svg.setAttribute("viewBox", viewBox);
                svg.setAttribute("preserveAspectRatio", "none");
                svg.setAttribute("width", width);
                svg.setAttribute("height", height);
                svg.style.width = `${width}px`;
                svg.style.height = `${height}px`;

                containerEl.style.width = `${width}px`;
                containerEl.style.height = `${height}px`;
                containerEl.style.transform = "scale(1)";
                //applyTransition(containerEl, ["width", "height"]);
            }

            resizeProjectorShapes({ backgroundSize, foregroundSize, radius = 15 }) {
                const el = this.elements;
                const [bgW, bgH] = backgroundSize;
                const [fgW, fgH] = foregroundSize;

                // resize the SVG containers (no change here)
                this._setSvgDimensions(el.background, el.background.querySelector('svg'), bgW, bgH);
                this._setSvgDimensions(el.foreground, el.foreground.querySelector('svg'), fgW, fgH);

                // generate “d” for each
                const bgD = this._generateNewD(bgW, bgH, radius);
                const fgD = this._generateNewD(fgW, fgH, radius);

                // morph background paths to bgD
                console.log('   morphing background →', bgD);
                morphAll(this._bgMorphPaths, bgD, { duration: 0.6, easing: 'ease-in-out' });

                // morph foreground paths to fgD
                console.log('   morphing foreground →', fgD);
                morphAll(this._fgMorphPaths, fgD, { duration: 0.6, easing: 'ease-in-out' });
            }

            resetTransform(el) {
                if (!el) return;
                applyTransition(el, "transform");
                el.style.transform = "translate(0, 0)";
            }

            setText(textEl, newText) {
                if (!textEl) return;
                const span = textEl.querySelector("span");
                if (!span) return;

                span.textContent = newText;
            }

            _setButtonState(btnEl, state) {
                if (!btnEl) return;
                if (state) { //enabled
                    btnEl.style.opacity = '100%';
                    btnEl.style.pointerEvents = 'auto';
                    btnEl.style.cursor = 'pointer';
                } else { //disabled
                    btnEl.style.opacity = '40%';
                    btnEl.style.pointerEvents = 'none';
                    btnEl.style.cursor = 'default';
                }
            }

            setProjectorState(state, isActionable) {
                const el = this.elements;
                const userNameSpan = el.userName.querySelector("span");
                if (!userNameSpan) return;

                if (state) {//is on
                    el.backgroundFill.style.fill = 'rgba(255,255,255, 0.04)';
                    el.backgroundOutline.style.stroke = 'rgba(255,255,255, 0.2)';
                    el.foregroundFill.style.fill = 'rgb(34,34,34)';
                    el.foregroundOutline.style.stroke = 'rgba(255,255,255, 0.2)';
                    el.userImg.style.fill = 'rgb(26,87,255)';
                    userNameSpan.style.color = 'rgba(228, 228, 228, 1)';

                    this._setButtonState(el.actionBtn, isActionable);
                    this._setButtonState(el.closeBtn, true);

                } else {//is off
                    el.backgroundFill.style.fill = 'rgba(255,255,255, 0.02)';
                    el.backgroundOutline.style.stroke = 'rgba(255,255,255, 0.1)';
                    el.foregroundFill.style.fill = 'rgb(34,34,34)';
                    el.foregroundOutline.style.stroke = 'rgba(255,255,255, 0.1)';
                    el.userImg.style.fill = 'rgba(26,87,255, 0.3)';
                    userNameSpan.style.color = 'rgba(228, 228, 228, 0.25)';

                    this._setButtonState(el.actionBtn, false);
                    this._setButtonState(el.closeBtn, false);
                }
            }
        }

        class DesignAsset {
            /**
            * @param {number} id
            * @param {string} title
            * @param {string} text
            * @param {string} pictureDataId
            * @param {bool} isActionable
            * @param {string[]} tweakDataId
            * @param {MediaType} mediaType
            */
            constructor(id, title, text, pictureDataId, isActionable, tweakDataId, mediaType) {
                this.id = id;
                this.title = title;
                this.text = text;
                this.pictureDataId = pictureDataId;
                this.isActionable = isActionable;
                this.tweakDataId = tweakDataId; //unused
                this.mediaType = mediaType;

                this.assetEl = document.querySelector(`div[data-id="${id}"]`);
                this.pictureEl = document.querySelector(`div[data-id="${this.pictureDataId}"]`);
                this._bindEvents();
                this._hidePictureOnInit();
            }

            _bindEvents() {
                if (!this.assetEl) return;

                this.assetEl.addEventListener("mousedown", () => {
                    const manager = new DesignAssetManager();
                    manager.setCurrentTarget(this);
                });
            }

            _hidePictureOnInit() {
                hideElement(this.pictureEl, true);
            }

            activate() {
                console.log(`=> ACTIVATING ${this.id}.`);
                //get (or create) the projector obj
                const projector = new Projector();
                //alias (for readability)
                const el = projector.elements;

                //switches the projector to appear on (visual effect)
                projector.setProjectorState(true, this.isActionable);
                //sets the projector size and positioning based on the mediaType (of the designAsset)
                const media = MediaFactory(this.mediaType);
                media.activate();

                //fills in the projector with the design asset (visual effect)
                hideElement(this.pictureEl, false);

                //sets the text based on the designAsset
                projector.setText(el.title, this.title);
                projector.setText(el.text, this.text);
                console.log(`=> ACTIVATING ${this.id}, returning.`);
            }

            deactivate() {
                console.log(`=> DEACTIVATING ${this.id}.`);
                const projector = new Projector();
                const el = projector.elements;

                projector.setProjectorState(false, false);

                const media = MediaFactory(this.mediaType);
                media.deactivate();

                hideElement(this.pictureEl, true);

                const defaultTitle = "abra cada bra";
                const defaultText = "moooooove something inside the super special magical projector pro plus R/m skibidi fast. COMES WITH..? YOU/ gusessed it ArITFICIAL intelligence.";
                projector.setText(el.title, defaultTitle);
                projector.setText(el.text, defaultText);
                console.log(`=> DEACTIVATING ${this.id}, returning.`);
            }
        }

        class DesignAssetManager {
            constructor() {
                if (DesignAssetManager.instance) return DesignAssetManager.instance;
                this.currentTarget = null;
                DesignAssetManager.instance = this;
            }

            setCurrentTarget(assetInstance) {
                this.currentTarget = assetInstance;
            }

            getCurrentTarget() {
                return this.currentTarget;
            }

            clearTarget() {
                this.currentTarget = null;
            }
        }

        class MediaType {
            activate() {
                throw new Error("unimplemented method.");
            }
            deactivate() {
                throw new Error("unimplemented method.");
            }
        }

        //implemented media types (concrete)
        class StoryMedia extends MediaType {
            activate() {
                const projector = new Projector();
                const el = projector.elements;

                projector.setOrigin(0, 0);

                //TEXT: position
                //position title
                projector.applyTransform(el.title, 0, 0);

                //position body
                projector.applyTransform(el.text, 0, 0);

                //PROJECTOR: resize 
                projector.resizeProjectorShapes({
                    backgroundSize: [195, 383],
                    foregroundSize: [177, 314],
                    radius: 15
                });

                //PROJECTOR: hide
                hideElement(el.hintText, true);

                //PROJECTOR: move
                //position bg
                projector.applyTransform(el.background, 47, -13);

                //position fg
                projector.applyTransform(el.foreground, 47, -16);

                //position userImg
                projector.applyTransform(el.userImg, 47, -14);

                //position userName
                projector.applyTransform(el.userName, 47, -17);

                //position closeBtn
                projector.applyTransform(el.closeBtn, -55, -14.83);

                //position actionBtn
                projector.applyTransform(el.actionBtn, -55, 16.17);

                //position actionBtnDisabled
                //projector.applyTransform(el.actionBtnDisabled, -55, 16.17);
            }
            deactivate() {
                const projector = new Projector();
                const el = projector.elements;

                projector.resetTransform(el.title);
                projector.resetTransform(el.text);
                projector.resetTransform(el.background);
                projector.resetTransform(el.foreground);
                projector.resetTransform(el.userImg);
                projector.resetTransform(el.userName);
                projector.resetTransform(el.closeBtn);
                projector.resetTransform(el.actionBtn);
                //projector.resetTransform(el.actionBtnDisabled);

                projector.resizeProjectorShapes({
                    backgroundSize: [298, 355],
                    foregroundSize: [281, 281],
                    radius: 15
                });

                hideElement(el.hintText, false);
            }
        }

        class PostMedia extends MediaType {
            activate() {
                //do nothing (its the default view)
            }
            deactivate() {
                //do nothing (its the default view)
            }
        }

        class VideoMedia extends MediaType {
            activate() {
                const projector = new Projector();
                const el = projector.elements;

                //projector.setOrigin(0, 0);

                //TEXT: position
                // projector.applyTransform(el.title, 62, 0);
                // projector.applyTransform(el.text, 62, 0);

                //PROJECTOR: resize 
                projector.resizeProjectorShapes({
                    backgroundSize: [517, 355],  // video bg
                    foregroundSize: [499, 281],  // video fg
                    radius: 15
                });

                //PROJECTOR: hide
                // hideElement(el.hintText, true);

                //PROJECTOR: move
                // projector.applyTransform(el.background, -63, 0);
                // projector.applyTransform(el.foreground, -62.99, 0);
                // projector.applyTransform(el.userImg, -63.99, 0);
                // projector.applyTransform(el.userName, -63.99, 0);
                // projector.applyTransform(el.closeBtn, 156, 0);
                // projector.applyTransform(el.actionBtn, 156, 0);
            }
            deactivate() {
                const projector = new Projector();
                const el = projector.elements;

                // projector.resetTransform(el.title);
                // projector.resetTransform(el.text);
                projector.resetTransform(el.background);
                projector.resetTransform(el.foreground);
                // projector.resetTransform(el.userImg);
                // projector.resetTransform(el.userName);
                // projector.resetTransform(el.closeBtn);
                // projector.resetTransform(el.actionBtn);

                projector.resizeProjectorShapes({
                    backgroundSize: [298, 355],
                    foregroundSize: [281, 281],
                    radius: 15
                });

                // hideElement(el.hintText, false);
            }
        }

        //utility map 4 singleton
        const SingletonRegistry = new Map();

        function getSingleton(ClassRef) {
            if (!SingletonRegistry.has(ClassRef)) {
                SingletonRegistry.set(ClassRef, new ClassRef());
            }
            return SingletonRegistry.get(ClassRef);
        }

        function MediaFactory(type) {
            const registry = {
                story: StoryMedia,
                post: PostMedia,
                video: VideoMedia
            };

            const ClassRef = registry[type];
            if (!ClassRef) throw new Error(`Unknown media type: ${type}`);

            return getSingleton(ClassRef);
        }

        //actual creation of design assets
        function createDesignAssetFromData(data) {
            return new DesignAsset(
                data.id,
                data.title,
                data.text,
                data.pictureDataId,
                data.isActionable,
                data.tweakDataId || [],
                data.mediaType
            );
        }

        const rawData = [
            {
                id: "67d47af15a2bcb42018765bb", //purple
                title: "Announcing HTU CC",
                text: "So, in here announced the Al-Hussein Technical University Coding Competition through a super amazing really cool post. It was amazing and I loved it of course becasue I designed it, I know amazing right?",
                pictureDataId: "67f95cc570965b325e806672",
                isActionable: true,
                tweakDataId: ["tw1", "tw2"],
                mediaType: "post"
            },
            {
                id: "67d47b040af04cc131e275e5", //cyan
                title: "crazy random stuff",
                text: "I ran out of brain rot so ur just gunna have tpo do with this shishishsis for now its my version of lorem ipsum, way better right? right? i love ketchup, its just so good. also i think im growing an armenian shawerma addiction.",
                pictureDataId: "67f95ceca23604ff63b6c116",
                isActionable: false,
                mediaType: "story"
            },
            {
                id: "67f95cac00fee003fa29b2f8", //pink
                title: "okay a slideshow this time",
                text: "i just need to change this text really wuick. yknow lorem ipsum would probably be faster but i need changing text each time to fully assess my design and prototype it. excellent usability testing process uhuh uhuh.",
                pictureDataId: "67f95d08231d4a07807e3c22",
                isActionable: false,
                mediaType: "video"
            }
        ];

        const designAssets = rawData.map(createDesignAssetFromData);

        //listener (optimize??)
        const throttledCallOnce = throttle(callOnce, 100);
        document.addEventListener("mousemove", throttledCallOnce);
        document.addEventListener("touchmove", throttledCallOnce);

        //initial call (upon page load)
        callOnce();
    </script>
</body>

</html>
</meta>

</html>